// TO COMPILE : gcc -o thread thread.c sha256.c ripemd160.c map.c -I. -L/usr/local/lib -lbase58 -lsecp256k1 -lncurses -lpthread
// IF ERROR ABOUT LOADING SHARED LIBRARIES: export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH

#include <stdio.h>
#include <assert.h>
#include <stdlib.h> // Include for exit and EXIT_FAILURE
#include <time.h>   // Include for time function
#include <string.h>
#include <unistd.h> // Include for usleep
#include "sha256.h"
#include "ripemd160.h"
#include <secp256k1.h>
#include "map.h"
#include "examples_util.h"
#include <pthread.h>
#include <ncurses.h> // Ensure ncurses.h is included for ncurses functions
#include <stdint.h>
#include "libbase58.h"

#define PUBKEY_SIZE 65
#define SHA256_HASH_SIZE 32
#define RIPEMD160_HASH_SIZE 20
#define HASH_HEX_SIZE 41
#define SLEEP_DURATION_US 1000 // Microseconds
#define ADDRESS_MAX_SIZE 35

#define NUM_THREADS 8 // Example number of threads

// Thread function prototype
void *thread_func(void *arg);

// Define a structure to hold aggregate statistics
typedef struct
{
    size_t total_pairs;
    size_t matches_found;
} AggregateStats;

// Global instance of the statistics
AggregateStats global_stats = {0, 0};

// Mutex for synchronizing access to the statistics
pthread_mutex_t stats_mutex = PTHREAD_MUTEX_INITIALIZER;

// Global mutex for hash map synchronization
pthread_mutex_t hashmap_mutex = PTHREAD_MUTEX_INITIALIZER;

typedef struct
{
    int thread_id;              // Identifier for the thread (useful for debugging or logging)
    size_t batch_size;          // Number of operations (key generations) to perform in one batch
    volatile bool should_stop;  // Flag to control when the thread should stop its execution
    size_t local_total_pairs;   // Local counter for total pairs generated by this thread
    size_t local_matches_found; // Local counter for matches found by this thread
    // Add any other necessary thread-specific data here
} ThreadData;

#define BATCH_SIZE 1000   // Adjusted for continuous generation
#define HASH_LENGTH 41    // Assuming hash length of 40 characters + null terminator
#define EXECUTION_TIME 30 // Duration for which the program should run in seconds

typedef struct
{
    unsigned char seckey[32];      // Private key
    unsigned char pubkey_hash[32]; // Hash of the public key
} keypair_hash;

// Global hash map
hashmap *m = NULL;

void hash_to_address(const unsigned char *hash, char *address)
{
    unsigned char versioned_hash[RIPEMD160_HASH_SIZE + 1];
    unsigned char checksum[32];
    unsigned char full_hash[RIPEMD160_HASH_SIZE + 5];
    size_t address_len = ADDRESS_MAX_SIZE;

    // Add version byte (0x00 for mainnet P2PKH)
    versioned_hash[0] = 0x00;
    memcpy(versioned_hash + 1, hash, RIPEMD160_HASH_SIZE);

    // Compute the checksum
    sha256(versioned_hash, RIPEMD160_HASH_SIZE + 1, checksum);
    sha256(checksum, 32, checksum); // Double SHA-256

    // Construct the full hash with version byte and checksum
    memcpy(full_hash, versioned_hash, RIPEMD160_HASH_SIZE + 1);
    memcpy(full_hash + RIPEMD160_HASH_SIZE + 1, checksum, 4);

    // Base58 encoding
    if (!b58enc(address, &address_len, full_hash, RIPEMD160_HASH_SIZE + 5))
    {
        fprintf(stderr, "Base58 encoding failed\n");
        exit(EXIT_FAILURE);
    }
}

// Function to read hashes from a file into a hash table
void read_hashes_to_map(const char *filename, hashmap *map)
{
    FILE *file = fopen(filename, "r");
    if (!file)
    {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    char hash[HASH_LENGTH];
    while (fscanf(file, "%40s", hash) == 1)
    {
        hashmap_set(map, hash, strlen(hash), 1);
    }

    fclose(file);
}

// Function to initialize and populate the hash map
void init_hash_map(const char *filename)
{
    m = hashmap_create();
    read_hashes_to_map(filename, m);
}

// Define the function to convert private keys to uncompressed public keys
void priv_to_pub(const unsigned char privkeys[][32], unsigned char pubkeys[][65], size_t num_keys, secp256k1_context *ctx, int type)
{
    for (size_t i = 0; i < num_keys; ++i)
    {
        secp256k1_pubkey pubkey;
        size_t len = 65; // Length for an uncompressed public key

        // Verify the secret key and create a public key
        assert(secp256k1_ec_seckey_verify(ctx, privkeys[i]));
        assert(secp256k1_ec_pubkey_create(ctx, &pubkey, privkeys[i]));

        if (type == 0)
        {
            // Serialize the public key in uncompressed format
            assert(secp256k1_ec_pubkey_serialize(ctx, pubkeys[i], &len, &pubkey, SECP256K1_EC_UNCOMPRESSED));
            assert(len == 65);
        }
        else
        {
            // Serialize the public key in uncompressed format
            assert(secp256k1_ec_pubkey_serialize(ctx, pubkeys[i], &len, &pubkey, SECP256K1_EC_COMPRESSED));
            assert(len == 33);
        }
    }
}

void hash_public_keys(const unsigned char *pubkeys, size_t num_keys, unsigned char *hashes_out, size_t pubkey_size)
{
    for (size_t i = 0; i < num_keys; ++i)
    {
        const unsigned char *pubkey = pubkeys + i * pubkey_size; // Adjust based on the size of the public key
        unsigned char *hash_out = hashes_out + i * 32;
        sha256(pubkey, pubkey_size, hash_out); // Use the correct public key size
    }
}

void bin_to_hex(const unsigned char *bin, size_t len, char *hex)
{
    const char *hex_digits = "0123456789abcdef";
    for (size_t i = 0; i < len; ++i)
    {
        hex[i * 2] = hex_digits[(bin[i] >> 4) & 0xF]; // Start from the first character
        hex[i * 2 + 1] = hex_digits[bin[i] & 0xF];    // Start from the second character
    }
}

int main(void)
{
    // Initialize ncurses
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    nodelay(stdscr, TRUE); // Set getch() non-blocking

    // Initialize thread data
    pthread_t threads[NUM_THREADS];
    ThreadData thread_data[NUM_THREADS];

    init_hash_map("master_addresses.txt"); // Ensure your hash map is initialized before threads start

    for (int i = 0; i < NUM_THREADS; ++i)
    {
        thread_data[i].thread_id = i;
        thread_data[i].batch_size = 1000;   // Set each thread to process 100,000 operations
        thread_data[i].should_stop = false; // Initially, don't signal threads to stop
        pthread_create(&threads[i], NULL, thread_func, (void *)&thread_data[i]);
    }

    bool running = true; // Use this flag to control the main loop
    time_t startTime = time(NULL);

    // Main loop for updating screen and managing threads
    while (running)
    {
        int ch = getch(); // Get user input
        if (ch == 'q' || ch == 'Q')
        { // Exit on 'q' press
            running = false;
            break;
        }

        // Calculate elapsed time
        time_t currentTime = time(NULL);
        double elapsedTime = difftime(currentTime, startTime);

        // Lock the mutex to safely read global_stats
        pthread_mutex_lock(&stats_mutex);
        double calculationsPerSecond = elapsedTime > 0 ? (double)global_stats.total_pairs / elapsedTime : 0;
        // Now you have safe copies of the data for displaying
        size_t totalGenerated = global_stats.total_pairs;
        size_t matchesFound = global_stats.matches_found;
        pthread_mutex_unlock(&stats_mutex);

        // Clear screen for fresh update
        clear();

        // Display the updated statistics
        mvprintw(0, 0, "Press 'q' to quit.");
        mvprintw(1, 0, "Elapsed Time: %.2f seconds", elapsedTime);
        mvprintw(2, 0, "Total Generated: %zu", totalGenerated);
        mvprintw(3, 0, "Calculations/Second: %.2f", calculationsPerSecond);
        mvprintw(4, 0, "Matches Found: %zu", matchesFound);
        refresh();       // Refresh the screen with new data
        usleep(1000000); // Slow down the loop to make it human-readable
    }

    // Signal all threads to stop and join them
    for (int i = 0; i < NUM_THREADS; ++i)
    {
        thread_data[i].should_stop = true;
        pthread_join(threads[i], NULL);
    }

    endwin(); // Clean up ncurses
    return 0;
}

void *thread_func(void *arg)
{
    ThreadData *data = (ThreadData *)arg;

    secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);
    if (ctx == NULL)
    {
        fprintf(stderr, "Failed to create secp256k1 context\n");
        exit(EXIT_FAILURE);
    }
    unsigned char randomize[32];
    assert(fill_random(randomize, sizeof(randomize)));
    assert(secp256k1_context_randomize(ctx, randomize));

    while (!data->should_stop)
    { // Loop indefinitely until 'should_stop' is true
        size_t local_total_pairs = 0, local_matches_found = 0;
        for (size_t i = 0; i < data->batch_size; ++i)
        {
            unsigned char pubkey_uncompressed[65], pubkey_compressed[33], sha256_hash[32], ripemd160_hash[20], address[ADDRESS_MAX_SIZE];
            unsigned char privkey[32];

            assert(fill_random(privkey, sizeof(privkey)));

            /*
            unsigned char privkey[1][32] = {
                {
                    0x1f, 0xe4, 0x6b, 0x9b, 0x9e, 0x5e, 0x7f, 0x6e,
                    0xa0, 0x38, 0x79, 0x33, 0x4f, 0x69, 0x86, 0x37,
                    0x93, 0x2e, 0x46, 0x8f, 0x0c, 0x6b, 0x72, 0x1a,
                    0x75, 0x39, 0xb1, 0xc0, 0x47, 0x9d, 0x05, 0x86
                }
            }; */

            priv_to_pub(&privkey, &pubkey_compressed, 1, ctx, 1);
            hash_public_keys(pubkey_compressed, 1, sha256_hash, 33);
            ripemd160(sha256_hash, 32, ripemd160_hash);
            hash_to_address(ripemd160_hash, address);

            uintptr_t value;
            if (hashmap_get(m, address, strlen(address), &value))
            {
                local_matches_found++;

                printf("Match found");

                // Convert private key to hex string
                char privkey_hex[65]; // Enough for 32-byte private key in hex + null terminator
                bin_to_hex(privkey, sizeof(privkey), privkey_hex);

                // Open matches.txt and append the match
                FILE *matches_file = fopen("matches.txt", "a");
                if (matches_file)
                {
                    fprintf(matches_file, "Private Key: %s, Hash: %s\n", privkey_hex, address);
                    fclose(matches_file);
                }
                else
                {
                    perror("Failed to open matches.txt");
                    // Handle error or log as needed
                }
            }

            priv_to_pub(&privkey, &pubkey_uncompressed, 1, ctx, 0);
            hash_public_keys(pubkey_uncompressed, 1, sha256_hash, 65);
            ripemd160(sha256_hash, 32, ripemd160_hash);
            hash_to_address(ripemd160_hash, address);

            if (hashmap_get(m, address, strlen(address), &value))
            {
                local_matches_found++;

                printf("Match found");

                // Convert private key to hex string
                char privkey_hex[65]; // Enough for 32-byte private key in hex + null terminator
                bin_to_hex(privkey, sizeof(privkey), privkey_hex);

                // Open matches.txt and append the match
                FILE *matches_file = fopen("matches.txt", "a");
                if (matches_file)
                {
                    fprintf(matches_file, "Private Key: %s, Hash: %s\n", privkey_hex, address);
                    fclose(matches_file);
                }
                else
                {
                    perror("Failed to open matches.txt");
                    // Handle error or log as needed
                }
            }

            local_total_pairs++;
            // Since this loop is running very fast, there's typically no need to check the time inside it
        }

        // Update global statistics outside of the for loop
        pthread_mutex_lock(&stats_mutex);
        global_stats.total_pairs += local_total_pairs;
        global_stats.matches_found += local_matches_found;
        pthread_mutex_unlock(&stats_mutex);

        // Check the 'should_stop' flag more frequently if needed
        if (data->should_stop)
            break;
    }

    secp256k1_context_destroy(ctx);
    return NULL;
}
